/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>


// 1.--- enable clocks ---
#define RCC_AHB1ENR (*(uint32_t*) 0x40023830)
#define RCC_APB1ENR (*(uint32_t*) 0x40023840)
#define RCC_APB2ENR (*(uint32_t*) 0x40023844)

// 2. --- CONFIGURE LED PA5 ---
#define GPIOA_MODER  (*(uint32_t*) 0x40020000)
#define GPIOA_ODR    (*(uint32_t*) 0x40020014)

// 3. --- CONFIGURE BUTTON PC13
#define GPIOC_MODER  (*(uint32_t*) 0x40020800)
#define GPIOC_PUPDR  (*(uint32_t*) 0x4002080C)
#define GPIOC_IDR    (*(uint32_t*) 0x40020810)

// 4. --- SET UP EXTI FOR BUTTON ---
#define SYSCFG_EXTICR4 (*(uint32_t*) 0x40013814) // activate for port 13
#define EXTI_IMR     (*(uint32_t*) 0x40013C00)
#define EXTI_FTSR    (*(uint32_t*) 0x40013C0C)
#define EXTI_PR      (*(uint32_t*) 0x40013C14)

#define NVIC_ISER1   (*(uint32_t*) 0xE000E104)

// 5. --- SET UP USART2 PA0 ---
   // its just mode and ODR again

#define USART_SR    (*(uint32_t*) 0x40004400)
#define USART_DR    (*(uint32_t*) 0x40004404)
#define USART_BRR   (*(uint32_t*) 0x40004408)
#define USART_CR1   (*(uint32_t*) 0x4000440C)

// 7. -- SET UP TIM2 ---
#define TIM2_CR1    (*(uint32_t*) 0x40000000)
#define TIM2_PSC    (*(uint32_t*) 0x40000028)
#define TIM2_ARR    (*(uint32_t*) 0x4000002C)
#define TIM2_DIER   (*(uint32_t*) 0x4000000C)
#define TIM2_SR     (*(uint32_t*)0x40000010)  // Status register

#define NVIC_ISER0  (*(uint32_t*) 0xE000E100)
// -- step 8 set up ISR
void TIM2_IRQHandler(void) {
	if (TIM2_SR & 1) {
		GPIOA_ODR ^= (1 << 5);
		TIM2_SR &= ~1;
	}
}

void EXTI15_10_IRQHandler(void) {
	if (EXTI_PR & (1 << 13)) {
		GPIOA_ODR ^= (1 << 5);
		EXTI_PR |= (1 << 13);

		while (!(USART_SR & (1 << 7)));  // wait for TXE (transmit empty)
		USART_DR = 'c';
	}
}




int main(void)

{
	// step 1
	RCC_AHB1ENR |= (1 << 0); // turns on GPIOA
	RCC_AHB1ENR |= (1 << 2); // turns on GPIOC

	RCC_APB1ENR |= (1 << 0); // turns on TIM2
	RCC_APB1ENR |= (1 << 17); // turns on USART2

	RCC_APB2ENR |= (1 << 8); // turns on ADC1
	RCC_APB2ENR |= (1 << 14); // turns on SYSCFG

	// step 2
	GPIOA_MODER &= ~(3 << (2 * 5)); // clears 2 bits
	GPIOA_MODER |= (1 << (2 * 5)); // sets output on pin 5

	GPIOA_ODR |= (1 << 5); // sets bit in output data register


	// step 3
	GPIOC_MODER &= ~(3 << (2 * 13)); // clears everything besides 2 bits
	GPIOC_MODER |= (0 << (2 * 13)); // sets input to PC13

	GPIOC_PUPDR &= ~(3 << (2 * 13));
	GPIOC_PUPDR |=  (1 << (2 * 13));   // pull-up




	// step 4
	SYSCFG_EXTICR4 &= ~(0xF << (1 *4));
	SYSCFG_EXTICR4 |= (2 << (1 * 4));

	EXTI_IMR |= (1 << 13);

	EXTI_FTSR |= (1 << 13);

	NVIC_ISER1 |= (1 << (40 -32));





	// step 5
	GPIOA_MODER &= ~(3 << (2 * 2));
	GPIOA_MODER |= (2 << (2 * 2));


	GPIOA_AFRL &= ~(0xF << (2 * 4));
	GPIOA_AFRL |= (7 << (2 * 4));

	USART_CR1 |= (1 << 13);
	USART_CR1 |= (1 << 3);

	// add baud rate
	USART_BRR = 0x0683; //9600



	// step 7 TIM2
	// how to set up the registers for this
	NVIC_ISER0 |= (1 << 28); // to turn on TIM2

	TIM2_PSC = 16000 - 1;
	TIM2_ARR = 1000 - 1;
	TIM2_DIER |= (1 << 0);
	TIM2_CR1 |= (1 << 0);

	//step 9
	while(1) {
		// ISRS are already handling everything
	}


}
