/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

// ==========================
// RCC (Reset and Clock Control) registers
// ==========================
// Used to enable the clocks for peripherals
#define RCC_AHB1ENR (*(uint32_t*) 0x40023830) // AHB1 peripheral clock enable
#define RCC_APB1ENR (*(uint32_t*) 0x40023840) // APB1 peripheral clock enable
#define RCC_APB2ENR (*(uint32_t*) 0x40023844) // APB2 peripheral clock enable

// ==========================
// GPIO (General Purpose I/O) registers
// ==========================
#define GPIOA_MODER   (*(uint32_t*) 0x40020000) // Mode register for GPIOA
#define GPIOA_ODR     (*(uint32_t*) 0x40020014) // Output data register for GPIOA
#define GPIOA_AFRL    (*(uint32_t*) 0x40020020) // Alternate function low register for GPIOA



#define GPIOC_MODER   (*(uint32_t*) 0x40020800) // Mode register for GPIOC
#define GPIOC_PUPDR   (*(uint32_t*) 0x4002080C) // Pull-up/pull-down register for GPIOC
#define GPIOC_IDR     (*(uint32_t*) 0x40020810) // Input data register for GPIOC


// ==========================
// EXTI (External Interrupts) + SYSCFG (System Config)
// ==========================
#define SYSCFG_EXTICR4 (*(uint32_t*) 0x40013814) // External interrupt configuration register 4
#define EXTI_IMR     (*(uint32_t*) 0x40013C00) // Interrupt mask register
#define EXTI_FTSR    (*(uint32_t*) 0x40013C0C) // Falling trigger selection register
#define EXTI_PR      (*(uint32_t*) 0x40013C14) // Pending register

// NVIC (Nested Vectored Interrupt Controller) interrupt set-enable registers
#define NVIC_ISER0     (*(uint32_t*) 0xE000E100)
#define NVIC_ISER1     (*(uint32_t*) 0xE000E104)


// ==========================
// USART2 (Universal Synchronous/Asynchronous Receiver/Transmitter)
// ==========================
#define USART_SR       (*(uint32_t*) 0x40004400) // Status register
#define USART_DR       (*(uint32_t*) 0x40004404) // Data register
#define USART_BRR      (*(uint32_t*) 0x40004408) // Baud rate register
#define USART_CR1      (*(uint32_t*) 0x4000440C) // Control register 1

// ==========================
// TIM2 (General-purpose timer)
// ==========================
#define TIM2_CR1       (*(uint32_t*) 0x40000000) // Control register 1
#define TIM2_DIER      (*(uint32_t*) 0x4000000C) // DMA/interrupt enable register
#define TIM2_SR        (*(uint32_t*) 0x40000010) // Status register
#define TIM2_PSC       (*(uint32_t*) 0x40000028) // Prescaler
#define TIM2_ARR       (*(uint32_t*) 0x4000002C) // Auto-reload register


// ==========================
// TIM2 Interrupt Service Routine
// ==========================
// Toggles LED on PA5 whenever TIM2 overflows
void TIM2_IRQHandler(void) {
	if (TIM2_SR & 1) {              // Check if update interrupt flag (UIF) is set
		GPIOA_ODR ^= (1 << 5);      // Toggle LED (PA5)
		TIM2_SR &= ~1;              // Clear interrupt flag
	}
}

// ==========================
// EXTI Interrupt Service Routine for PC13 (User Button)
// ==========================
// Toggles LED and sends a character over USART2 when button is pressed
void EXTI15_10_IRQHandler(void) {
	if (EXTI_PR & (1 << 13)) {      // Check if interrupt pending on line 13
		GPIOA_ODR ^= (1 << 5);      // Toggle LED (PA5)
		EXTI_PR |= (1 << 13);       // Clear interrupt pending flag

		// Send character 'c' over USART2
		while (!(USART_SR & (1 << 7))); // Wait until TXE (Transmit data register empty)
		USART_DR = 'c';
	}
}



int main(void)

{
	// ==========================
	// STEP 1: Enable peripheral clocks
	// ==========================
	RCC_AHB1ENR |= (1 << 0);   // Enable GPIOA clock
	RCC_AHB1ENR |= (1 << 2);   // Enable GPIOC clock
	RCC_APB1ENR |= (1 << 0);   // Enable TIM2 clock
	RCC_APB1ENR |= (1 << 17);  // Enable USART2 clock
	RCC_APB2ENR |= (1 << 14);  // Enable SYSCFG clock (needed for EXTI)

	// ==========================
	// STEP 2: Configure PA5 as output (LED)
	// ==========================
	GPIOA_MODER &= ~(3 << (2 * 5)); // Clear mode bits for PA5
	GPIOA_MODER |= (1 << (2 * 5));  // Set PA5 as General Purpose Output

	// ==========================
	// STEP 3: Configure PC13 as input (User Button)
	// ==========================
	GPIOC_MODER &= ~(3 << (2 * 13)); // clears everything besides 2 bits
	GPIOC_MODER |= (0 << (2 * 13)); // sets input to PC13
	GPIOC_PUPDR &= ~(3 << (2 * 13)); // Clear pull configuration
	GPIOC_PUPDR |=  (1 << (2 * 13)); // Enable pull-up resistor on PC13




	// ==========================
	// STEP 4: Configure EXTI for PC13
	// ==========================
	SYSCFG_EXTICR4 &= ~(0xF << (1 * 4)); // Clear EXTI13 config
	SYSCFG_EXTICR4 |=  (2 << (1 * 4));   // Route EXTI13 to Port C
	EXTI_IMR |= (1 << 13);               // Unmask EXTI line 13
	EXTI_FTSR |= (1 << 13);              // Trigger on falling edge
	NVIC_ISER1 |= (1 << (40 - 32));      // Enable EXTI15_10 interrupt in NVIC





	// ==========================
	// STEP 5: Configure PA2 for USART2 TX (Alternate Function 7)
	// ==========================
	GPIOA_MODER &= ~(3 << (2 * 2));      // Clear mode bits for PA2
	GPIOA_MODER |=  (2 << (2 * 2));      // Set PA2 to Alternate Function mode
	GPIOA_AFRL &= ~(0xF << (2 * 4));     // Clear AF bits for PA2
	GPIOA_AFRL |=  (7 << (2 * 4));       // Set AF7 (USART2_TX) on PA2

	// USART2 configuration
	USART_CR1 |= (1 << 13);              // Enable USART
	USART_CR1 |= (1 << 3);               // Enable Transmitter
	USART_BRR = 0x0683;
	// Sets baud rate to 9600 bps with 16 MHz clock.
	// Calculated as 16,000,000 / 9600 ≈ 1667 → 0x0683 in BRR register.


	// ==========================
	// STEP 6: Configure TIM2 for periodic interrupts
	// ==========================
	NVIC_ISER0 |= (1 << 28);
	TIM2_PSC = 16000 - 1;
	// The prescaler divides the 16 MHz system clock.
	// PSC register value = (desired_divider - 1).
	// So with PSC = 15999, the actual divider is 16000.
	// 16 MHz / 16000 = 1 kHz timer tick (1 ms per tick).

	TIM2_ARR = 1000 - 1;
	// The auto-reload register sets the period.
	// ARR value = (desired_counts - 1).
	// So ARR = 999 → timer counts 1000 ticks before overflowing.
	// At 1 kHz tick frequency, 1000 ticks = 1 second.// Enable TIM2 interrupt in NVIC
	TIM2_DIER |= (1 << 0);               // Enable update interrupt
	TIM2_CR1  |= (1 << 0);               // Enable TIM2 counter

	// ==========================
	// STEP 9: Main loop
	// ==========================
	while(1) {
		// All work is handled in the interrupt service routines (ISR)
	}


}
